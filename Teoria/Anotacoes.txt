Spring MVC pattern com Spring Web

password postgrees: 586910

- O framework Spring Web utiliza o padr√£o MVC
- No momento que a Request chega na API, o componente DispatcherServlet (Com o Spring Boot, as configura√ß√µes ficam encapsuladas), mas em resumo no momento em que a request chega, o DispatcherServlet recebe a solicita√ß√£o, e utilizar√° do HandlerMapping que ir√° fazer o mapeamento /roteamento encontrando qual controller ir√° responder a aquela request, que por sua vez ter√° acesso a camada de neg√≥cio e ir√° trabalhar com o modelo e l√≥gica de neg√≥cio.
- Em uma aplica√ß√£o que tamb√©m possui view, o DispatcherServlet utiliza o ViewResolver para reconhecer a view determinada da request.
- Tomcat: ServletContainer (Spring Web, encapsula o funcionamento).

-- VALIDA√á√ïES --

Jakarta Bean Validation

√â uma especifica√ß√£o Java que possibilita trabalhar com valida√ß√µes e restri√ß√µes atrav√©s de anota√ß√µes.

Dependencia Spring Validation.

Annotations:

@NotBlank: Onde o atributo n√£o pode ser null e n√£o pode ser uma String vazia.

@Email: Verificar o padr√£o de email por meio de regex.

@NotNull: N√£o aceita valores nulos.

@Size: Define um tamanho limite de caracteres para a String.

@Min e @Max: Estabelece valores especificos no qual tipos Number s√£o delimitados.

@Past e @Future: Delimita campos do tipo Date e Calendar como passado e futuro respectivamente.

@AssertTrue @AssertFalse: Restringe que o atributo precisa ser booleano True ou False.

### Explica√ß√£o das Annotations `@Validated` e `@JsonView`

No seu c√≥digo, as annotations `@Validated` e `@JsonView` s√£o utilizadas para validar e controlar a serializa√ß√£o/desserializa√ß√£o dos dados, respectivamente.

---

### üìå **`@Validated`**
- Faz parte do **Spring** (`org.springframework.validation.annotation.Validated`).
- Permite validar objetos com **Bean Validation** (JSR-303/JSR-380), como `@NotBlank`, `@Size`, `@Email`, entre outras.
- Aceita **grupos de valida√ß√£o**, que permitem definir regras de valida√ß√£o diferentes para diferentes cen√°rios.

#### **No seu c√≥digo**
```java
@RequestBody @Validated(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Aqui, `@Validated(UserRecordDto.UserView.UserPut.class)` diz que apenas as valida√ß√µes associadas ao grupo `UserView.UserPut.class` devem ser aplicadas. Isso significa que, ao chamar esse endpoint, apenas os campos validados com esse grupo (por exemplo, `fullName` e `phoneNumber`) ser√£o checados.

---

### üìå **`@JsonView`**
- Faz parte do **Jackson** (`com.fasterxml.jackson.annotation.JsonView`).
- Controla **quais campos ser√£o serializados** (retornados na resposta) ou **desserializados** (recebidos no request).
- Funciona com **interfaces vazias** para definir diferentes "vis√µes" (`views`) de um mesmo DTO.

#### **No seu c√≥digo**
```java
@JsonView(UserView.RegistrationPost.class)
String username;
```
Isso significa que o campo `username` **s√≥ ser√° inclu√≠do na resposta se a view `UserView.RegistrationPost.class` estiver sendo usada**.

Da mesma forma, no m√©todo `updateUser`:
```java
@RequestBody @JsonView(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Isso indica que **apenas os campos marcados com `UserPut` ser√£o desserializados do JSON enviado no request**.

---

### üöÄ **Resumindo**
1. **`@Validated`** ‚Üí Aplica **valida√ß√µes condicionais** dependendo do grupo especificado no request.
2. **`@JsonView`** ‚Üí Controla **quais campos aparecem na requisi√ß√£o e resposta**, dependendo da view definida.

Isso permite maior flexibilidade, garantindo que **diferentes endpoints apliquem regras e retornem apenas os dados necess√°rios**.


-- JPA,  SPRING DATA JPA e HIBERNATE --

N√£o exatamente. **Spring Data JPA e Hibernate n√£o s√£o duas abstra√ß√µes do JPA**, mas sim tecnologias diferentes que interagem com ele de maneiras distintas.

---

## üîπ **JPA (Java Persistence API)**
JPA √© apenas uma **especifica√ß√£o** (ou seja, um conjunto de interfaces e regras) para gerenciamento de persist√™ncia em Java.  
Ele define como as entidades devem ser mapeadas para o banco de dados, mas **n√£o implementa nada por si s√≥**.

üëâ Para usar JPA, √© necess√°rio um **provedor de persist√™ncia** que implemente essa especifica√ß√£o. √â a√≠ que entra o Hibernate.

---

## üîπ **Hibernate**
O **Hibernate** √© a implementa√ß√£o **mais popular** do JPA. Ele fornece:
‚úî Um provedor de persist√™ncia JPA.  
‚úî Recursos extras al√©m do que o JPA especifica.  
‚úî Funcionalidades avan√ßadas como caching, lazy loading otimizado e query caching.

Ou seja, **Hibernate √© um ORM (Object-Relational Mapping) que implementa JPA**.  

‚û° Voc√™ pode usar Hibernate diretamente sem JPA, mas o ideal √© usar JPA para manter seu c√≥digo mais gen√©rico e desacoplado da implementa√ß√£o.

---

## üîπ **Spring Data JPA**
O **Spring Data JPA** √© uma **abstra√ß√£o sobre o JPA** que simplifica o uso do JPA/Hibernate no Spring. Ele fornece:
‚úî Implementa√ß√£o autom√°tica de reposit√≥rios (`JpaRepository`, `CrudRepository`).  
‚úî M√©todos de consulta personalizados sem precisar escrever SQL (`findByEmail`, `findByNameContaining`).  
‚úî Integra√ß√£o f√°cil com o **Spring Boot**.  
‚úî Redu√ß√£o dr√°stica da quantidade de c√≥digo boilerplate.

‚ö° **Ou seja:** O Spring Data JPA usa o JPA (e, indiretamente, o Hibernate) para facilitar a persist√™ncia.

---

## üéØ **Resumindo a Diferen√ßa**
| Tecnologia        | O que √©? | Implementa√ß√£o |
|------------------|---------|---------------|
| **JPA**          | Especifica√ß√£o (interfaces e regras) | N√£o tem implementa√ß√£o pr√≥pria |
| **Hibernate**    | ORM que implementa JPA | Sim, √© um provedor de persist√™ncia |
| **Spring Data JPA** | Abstra√ß√£o do JPA dentro do Spring | Usa JPA e um provedor como Hibernate |

üîπ **JPA** define as regras.  
üîπ **Hibernate** implementa essas regras.  
üîπ **Spring Data JPA** facilita o uso do JPA e do Hibernate no Spring.

Se estiver usando **Spring Boot**, o Hibernate √© o provedor padr√£o do Spring Data JPA, ent√£o ao configurar um banco, ele j√° ser√° utilizado automaticamente. üöÄ
