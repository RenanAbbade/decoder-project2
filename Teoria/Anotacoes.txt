Spring MVC pattern com Spring Web

password postgrees: 586910

- O framework Spring Web utiliza o padr√£o MVC
- No momento que a Request chega na API, o componente DispatcherServlet (Com o Spring Boot, as configura√ß√µes ficam encapsuladas), mas em resumo no momento em que a request chega, o DispatcherServlet recebe a solicita√ß√£o, e utilizar√° do HandlerMapping que ir√° fazer o mapeamento /roteamento encontrando qual controller ir√° responder a aquela request, que por sua vez ter√° acesso a camada de neg√≥cio e ir√° trabalhar com o modelo e l√≥gica de neg√≥cio.
- Em uma aplica√ß√£o que tamb√©m possui view, o DispatcherServlet utiliza o ViewResolver para reconhecer a view determinada da request.
- Tomcat: ServletContainer (Spring Web, encapsula o funcionamento).

-- VALIDA√á√ïES --

Jakarta Bean Validation

√â uma especifica√ß√£o Java que possibilita trabalhar com valida√ß√µes e restri√ß√µes atrav√©s de anota√ß√µes.

Dependencia Spring Validation.

Annotations:

@NotBlank: Onde o atributo n√£o pode ser null e n√£o pode ser uma String vazia.

@Email: Verificar o padr√£o de email por meio de regex.

@NotNull: N√£o aceita valores nulos.

@Size: Define um tamanho limite de caracteres para a String.

@Min e @Max: Estabelece valores especificos no qual tipos Number s√£o delimitados.

@Past e @Future: Delimita campos do tipo Date e Calendar como passado e futuro respectivamente.

@AssertTrue @AssertFalse: Restringe que o atributo precisa ser booleano True ou False.

### Explica√ß√£o das Annotations `@Validated` e `@JsonView`

No seu c√≥digo, as annotations `@Validated` e `@JsonView` s√£o utilizadas para validar e controlar a serializa√ß√£o/desserializa√ß√£o dos dados, respectivamente.

---

### üìå **`@Validated`**
- Faz parte do **Spring** (`org.springframework.validation.annotation.Validated`).
- Permite validar objetos com **Bean Validation** (JSR-303/JSR-380), como `@NotBlank`, `@Size`, `@Email`, entre outras.
- Aceita **grupos de valida√ß√£o**, que permitem definir regras de valida√ß√£o diferentes para diferentes cen√°rios.

#### **No seu c√≥digo**
```java
@RequestBody @Validated(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Aqui, `@Validated(UserRecordDto.UserView.UserPut.class)` diz que apenas as valida√ß√µes associadas ao grupo `UserView.UserPut.class` devem ser aplicadas. Isso significa que, ao chamar esse endpoint, apenas os campos validados com esse grupo (por exemplo, `fullName` e `phoneNumber`) ser√£o checados.

---

### üìå **`@JsonView`**
- Faz parte do **Jackson** (`com.fasterxml.jackson.annotation.JsonView`).
- Controla **quais campos ser√£o serializados** (retornados na resposta) ou **desserializados** (recebidos no request).
- Funciona com **interfaces vazias** para definir diferentes "vis√µes" (`views`) de um mesmo DTO.

#### **No seu c√≥digo**
```java
@JsonView(UserView.RegistrationPost.class)
String username;
```
Isso significa que o campo `username` **s√≥ ser√° inclu√≠do na resposta se a view `UserView.RegistrationPost.class` estiver sendo usada**.

Da mesma forma, no m√©todo `updateUser`:
```java
@RequestBody @JsonView(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Isso indica que **apenas os campos marcados com `UserPut` ser√£o desserializados do JSON enviado no request**.

---

### üöÄ **Resumindo**
1. **`@Validated`** ‚Üí Aplica **valida√ß√µes condicionais** dependendo do grupo especificado no request.
2. **`@JsonView`** ‚Üí Controla **quais campos aparecem na requisi√ß√£o e resposta**, dependendo da view definida.

Isso permite maior flexibilidade, garantindo que **diferentes endpoints apliquem regras e retornem apenas os dados necess√°rios**.


-- JPA,  SPRING DATA JPA e HIBERNATE --

N√£o exatamente. **Spring Data JPA e Hibernate n√£o s√£o duas abstra√ß√µes do JPA**, mas sim tecnologias diferentes que interagem com ele de maneiras distintas.

---

## üîπ **JPA (Java Persistence API)**
JPA √© apenas uma **especifica√ß√£o** (ou seja, um conjunto de interfaces e regras) para gerenciamento de persist√™ncia em Java.  
Ele define como as entidades devem ser mapeadas para o banco de dados, mas **n√£o implementa nada por si s√≥**.

üëâ Para usar JPA, √© necess√°rio um **provedor de persist√™ncia** que implemente essa especifica√ß√£o. √â a√≠ que entra o Hibernate.

---

## üîπ **Hibernate**
O **Hibernate** √© a implementa√ß√£o **mais popular** do JPA. Ele fornece:
‚úî Um provedor de persist√™ncia JPA.  
‚úî Recursos extras al√©m do que o JPA especifica.  
‚úî Funcionalidades avan√ßadas como caching, lazy loading otimizado e query caching.

Ou seja, **Hibernate √© um ORM (Object-Relational Mapping) que implementa JPA**.  

‚û° Voc√™ pode usar Hibernate diretamente sem JPA, mas o ideal √© usar JPA para manter seu c√≥digo mais gen√©rico e desacoplado da implementa√ß√£o.

---

## üîπ **Spring Data JPA**
O **Spring Data JPA** √© uma **abstra√ß√£o sobre o JPA** que simplifica o uso do JPA/Hibernate no Spring. Ele fornece:
‚úî Implementa√ß√£o autom√°tica de reposit√≥rios (`JpaRepository`, `CrudRepository`).  
‚úî M√©todos de consulta personalizados sem precisar escrever SQL (`findByEmail`, `findByNameContaining`).  
‚úî Integra√ß√£o f√°cil com o **Spring Boot**.  
‚úî Redu√ß√£o dr√°stica da quantidade de c√≥digo boilerplate.

‚ö° **Ou seja:** O Spring Data JPA usa o JPA (e, indiretamente, o Hibernate) para facilitar a persist√™ncia.

---

## üéØ **Resumindo a Diferen√ßa**
| Tecnologia        | O que √©? | Implementa√ß√£o |
|------------------|---------|---------------|
| **JPA**          | Especifica√ß√£o (interfaces e regras) | N√£o tem implementa√ß√£o pr√≥pria |
| **Hibernate**    | ORM que implementa JPA | Sim, √© um provedor de persist√™ncia |
| **Spring Data JPA** | Abstra√ß√£o do JPA dentro do Spring | Usa JPA e um provedor como Hibernate |

üîπ **JPA** define as regras.  
üîπ **Hibernate** implementa essas regras.  
üîπ **Spring Data JPA** facilita o uso do JPA e do Hibernate no Spring.

Se estiver usando **Spring Boot**, o Hibernate √© o provedor padr√£o do Spring Data JPA, ent√£o ao configurar um banco, ele j√° ser√° utilizado automaticamente. üöÄ

No **Hibernate** e **Spring Data JPA**, h√° v√°rias formas de realizar consultas no banco de dados. A escolha da abordagem depende da complexidade da consulta e do n√≠vel de abstra√ß√£o desejado.  

---

## üîπ **1. Consultas Usando M√©todos de Interface (`Derived Query Methods`)**  
O **Spring Data JPA** permite definir consultas diretamente no nome do m√©todo da interface do reposit√≥rio.  

### ‚úÖ Exemplo:
```java
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByUsername(String username);
    List<User> findByEmailContaining(String emailPart);
    List<User> findByCreatedAtAfter(LocalDateTime date);
}
```
üìå **Como funciona?** O Spring analisa o nome do m√©todo, gera automaticamente a consulta e a executa.  
‚úî F√°cil de usar, mas limitado a consultas mais simples.  

---

## üîπ **2. Consultas Usando `@Query` (JPQL ou SQL Nativo)**
Para consultas mais complexas, podemos usar **JPQL** (Java Persistence Query Language) ou SQL nativo.

### ‚úÖ **JPQL (Java Persistence Query Language)**
JPQL √© semelhante ao SQL, mas opera sobre **entidades e atributos**, n√£o sobre tabelas e colunas.  

```java
@Query("SELECT u FROM User u WHERE u.email = :email")
User findByEmail(@Param("email") String email);
```

### ‚úÖ **SQL Nativo**
Se precisar de uma consulta mais otimizada diretamente no banco, pode usar **SQL puro**:  

```java
@Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
User findByEmailNative(@Param("email") String email);
```

üìå **JPQL √© mais port√°til**, enquanto **SQL nativo pode ser mais perform√°tico** dependendo do banco de dados.

---

## üîπ **3. Consultas Usando `EntityManager` e `Criteria API`**
Se precisar de mais flexibilidade, pode usar o `EntityManager` para criar queries din√¢micas.  

### ‚úÖ **Usando `EntityManager` (JPQL)**
```java
@Autowired
private EntityManager entityManager;

public List<User> findUsersCreatedAfter(LocalDateTime date) {
    String jpql = "SELECT u FROM User u WHERE u.createdAt > :date";
    return entityManager.createQuery(jpql, User.class)
                        .setParameter("date", date)
                        .getResultList();
}
```

### ‚úÖ **Usando `Criteria API` (Consulta Din√¢mica)**
A Criteria API permite construir consultas dinamicamente, √∫til para filtros flex√≠veis.  

```java
public List<User> findUsersByCriteria(String username, String email) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    List<Predicate> predicates = new ArrayList<>();
    if (username != null) {
        predicates.add(cb.equal(user.get("username"), username));
    }
    if (email != null) {
        predicates.add(cb.like(user.get("email"), "%" + email + "%"));
    }
    
    cq.where(predicates.toArray(new Predicate[0]));
    return entityManager.createQuery(cq).getResultList();
}
```

üìå **Vantagem da Criteria API** ‚Üí Boa para **constru√ß√£o din√¢mica** de consultas sem manipular strings manualmente.

---

## üîπ **4. Consultas Usando `Specification` (Spring Data JPA)**
Para consultas din√¢micas e reutiliz√°veis, o Spring oferece a interface `Specification<T>`, baseada na **Criteria API**.

### ‚úÖ **Exemplo de `Specification`**
```java
public class UserSpecification {
    public static Specification<User> hasUsername(String username) {
        return (root, query, cb) -> cb.equal(root.get("username"), username);
    }

    public static Specification<User> emailContains(String email) {
        return (root, query, cb) -> cb.like(root.get("email"), "%" + email + "%");
    }
}
```
Agora podemos combinar as condi√ß√µes dinamicamente:

```java
List<User> users = userRepository.findAll(Specification
        .where(UserSpecification.hasUsername("john"))
        .and(UserSpecification.emailContains("@gmail.com")));
```
üìå **√ìtimo para filtros din√¢micos e complexos!**  

---

## üîπ **5. Consultas Usando `NamedQuery`**
Podemos definir queries diretamente na entidade.

### ‚úÖ **Exemplo**
```java
@Entity
@NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email")
public class User { ... }
```
E no reposit√≥rio:
```java
User user = userRepository.findByEmail("test@example.com");
```

üìå **√ötil para reuso de queries, mas menos flex√≠vel que `@Query` ou Criteria API.**

---

## üéØ **Resumo das Formas de Consulta**
| M√©todo | Caracter√≠sticas | Melhor para |
|--------|---------------|-------------|
| **Derived Queries** (`findByUsername`) | Baseado no nome do m√©todo, sem SQL | Consultas simples |
| **JPQL (`@Query`)** | Usa linguagem baseada em entidades | Consultas intermedi√°rias |
| **SQL Nativo (`@Query(nativeQuery = true)`)** | SQL puro, mais perform√°tico | Consultas espec√≠ficas do banco |
| **EntityManager (JPQL ou Criteria API)** | Total controle da query | Consultas complexas e din√¢micas |
| **Specification API** | Combina filtros dinamicamente | Filtros avan√ßados e reutiliz√°veis |
| **NamedQuery** | Definido na entidade, reutiliz√°vel | Queries fixas |

Se precisar de algo **r√°pido e simples**, `Derived Queries` e `@Query` s√£o boas op√ß√µes.  
Se precisar de algo **din√¢mico**, `Criteria API` ou `Specification` s√£o mais adequados. üöÄ



--  API Specification -- 

Esse c√≥digo usa a **Specification API** do Spring Data JPA, combinada com a biblioteca **Spring Specification Argument Resolver**, para permitir que a API filtre usu√°rios dinamicamente com base nos par√¢metros enviados na requisi√ß√£o.  

Vamos analisar os trechos de c√≥digo:

---

## **1Ô∏è‚É£ M√©todo `getAllUsers`**
```java
@GetMapping
public ResponseEntity<Page<UserModel>> getAllUsers(SpecificationTemplate.UserSpec spec, Pageable pageable){
    Page<UserModel> userModelPage = userService.findAll(spec, pageable);
    
    if(!userModelPage.isEmpty()){
        for(UserModel user : userModelPage.toList()){
            user.add(linkTo(methodOn(UserController.class).getOneUser(user.getUserId())).withSelfRel());
        }
    }
    
    return ResponseEntity.status(HttpStatus.OK).body(userModelPage);
}
```
### üîπ O que esse m√©todo faz?
- **Recebe uma requisi√ß√£o `GET` para buscar usu√°rios**.
- **Aceita filtros din√¢micos** via `SpecificationTemplate.UserSpec` (explicado na pr√≥xima se√ß√£o).
- **Aceita pagina√ß√£o** via `Pageable` (Spring Data JPA suporta pagina√ß√£o autom√°tica).
- **Chama `userService.findAll(spec, pageable)`**, que retorna os usu√°rios filtrados e paginados.
- **Adiciona links HATEOAS** aos usu√°rios para facilitar navega√ß√£o na API REST.
- **Retorna os resultados com c√≥digo HTTP 200 (OK)**.

---

## **2Ô∏è‚É£ `SpecificationTemplate` - Criando Filtros Din√¢micos**
```java
public class SpecificationTemplate {

    @And({
            @Spec(path = "userType", spec = Equal.class),
            @Spec(path = "userStatus", spec = Equal.class),
            @Spec(path = "email", spec = Like.class),
            @Spec(path = "username", spec = Like.class),
            @Spec(path = "fullName", spec = LikeIgnoreCase.class)
    })
    public interface UserSpec extends Specification<UserModel> {}
}
```

### üîπ O que essa classe faz?
Ela define um conjunto de **especifica√ß√µes din√¢micas** para que os usu√°rios possam ser filtrados atrav√©s de par√¢metros na URL.

- **`@And({...})`** ‚Üí Indica que todas as condi√ß√µes dentro dela podem ser combinadas.
- **`@Spec(path = "...", spec = Tipo.class)`** ‚Üí Define a regra de filtragem para cada campo:
  - `Equal.class` ‚Üí Busca valores **exatamente iguais** (`userType`, `userStatus`).
  - `Like.class` ‚Üí Busca valores **contendo um trecho do texto** (`email`, `username`).
  - `LikeIgnoreCase.class` ‚Üí Busca valores **contendo um trecho do texto, ignorando mai√∫sculas/min√∫sculas** (`fullName`).

### üîπ Como usar na requisi√ß√£o?
Como essa interface estende `Specification<UserModel>`, o Spring Data JPA consegue processar automaticamente os par√¢metros da URL para realizar as consultas.

‚úÖ **Exemplo de requisi√ß√£o GET com filtros din√¢micos:**
```http
GET /users?username=john&email=@gmail.com
```
üîπ Isso resultaria em uma consulta SQL equivalente a:
```sql
SELECT * FROM users 
WHERE username LIKE '%john%' 
AND email LIKE '%@gmail.com%'
```

---

## **3Ô∏è‚É£ Como Funciona o `findAll(spec, pageable)`?**
A chamada `userService.findAll(spec, pageable)` dentro do m√©todo `getAllUsers` retorna os usu√°rios filtrados e paginados.

### **No `UserService`:**
```java
public Page<UserModel> findAll(Specification<UserModel> spec, Pageable pageable) {
    return userRepository.findAll(spec, pageable);
}
```
### **No `UserRepository`:**
```java
public interface UserRepository extends JpaRepository<UserModel, UUID>, JpaSpecificationExecutor<UserModel> {}
```
üìå **A interface `JpaSpecificationExecutor` permite consultas din√¢micas usando `Specification<T>`**.

---

## **üî• Resumo Geral**
‚úî **Filtragem Din√¢mica**: Os usu√°rios podem ser filtrados por qualquer combina√ß√£o de par√¢metros na URL.  
‚úî **Uso de Specification API**: Permite consultas flex√≠veis sem necessidade de escrever queries SQL.  
‚úî **Pagina√ß√£o Autom√°tica**: O `Pageable` facilita a implementa√ß√£o de pagina√ß√£o.  
‚úî **HATEOAS**: Links s√£o adicionados a cada usu√°rio, facilitando a navega√ß√£o na API REST.  

Esse padr√£o √© muito √∫til para construir APIs REST escal√°veis e flex√≠veis. üöÄ
