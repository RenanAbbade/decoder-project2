Spring MVC pattern com Spring Web

password postgrees: 586910

- O framework Spring Web utiliza o padr√£o MVC
- No momento que a Request chega na API, o componente DispatcherServlet (Com o Spring Boot, as configura√ß√µes ficam encapsuladas), mas em resumo no momento em que a request chega, o DispatcherServlet recebe a solicita√ß√£o, e utilizar√° do HandlerMapping que ir√° fazer o mapeamento /roteamento encontrando qual controller ir√° responder a aquela request, que por sua vez ter√° acesso a camada de neg√≥cio e ir√° trabalhar com o modelo e l√≥gica de neg√≥cio.
- Em uma aplica√ß√£o que tamb√©m possui view, o DispatcherServlet utiliza o ViewResolver para reconhecer a view determinada da request.
- Tomcat: ServletContainer (Spring Web, encapsula o funcionamento).

-- VALIDA√á√ïES --

Jakarta Bean Validation

√â uma especifica√ß√£o Java que possibilita trabalhar com valida√ß√µes e restri√ß√µes atrav√©s de anota√ß√µes.

Dependencia Spring Validation.

Annotations:

@NotBlank: Onde o atributo n√£o pode ser null e n√£o pode ser uma String vazia.

@Email: Verificar o padr√£o de email por meio de regex.

@NotNull: N√£o aceita valores nulos.

@Size: Define um tamanho limite de caracteres para a String.

@Min e @Max: Estabelece valores especificos no qual tipos Number s√£o delimitados.

@Past e @Future: Delimita campos do tipo Date e Calendar como passado e futuro respectivamente.

@AssertTrue @AssertFalse: Restringe que o atributo precisa ser booleano True ou False.

### Explica√ß√£o das Annotations `@Validated` e `@JsonView`

No seu c√≥digo, as annotations `@Validated` e `@JsonView` s√£o utilizadas para validar e controlar a serializa√ß√£o/desserializa√ß√£o dos dados, respectivamente.

---

### üìå **`@Validated`**
- Faz parte do **Spring** (`org.springframework.validation.annotation.Validated`).
- Permite validar objetos com **Bean Validation** (JSR-303/JSR-380), como `@NotBlank`, `@Size`, `@Email`, entre outras.
- Aceita **grupos de valida√ß√£o**, que permitem definir regras de valida√ß√£o diferentes para diferentes cen√°rios.

#### **No seu c√≥digo**
```java
@RequestBody @Validated(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Aqui, `@Validated(UserRecordDto.UserView.UserPut.class)` diz que apenas as valida√ß√µes associadas ao grupo `UserView.UserPut.class` devem ser aplicadas. Isso significa que, ao chamar esse endpoint, apenas os campos validados com esse grupo (por exemplo, `fullName` e `phoneNumber`) ser√£o checados.

---

### üìå **`@JsonView`**
- Faz parte do **Jackson** (`com.fasterxml.jackson.annotation.JsonView`).
- Controla **quais campos ser√£o serializados** (retornados na resposta) ou **desserializados** (recebidos no request).
- Funciona com **interfaces vazias** para definir diferentes "vis√µes" (`views`) de um mesmo DTO.

#### **No seu c√≥digo**
```java
@JsonView(UserView.RegistrationPost.class)
String username;
```
Isso significa que o campo `username` **s√≥ ser√° inclu√≠do na resposta se a view `UserView.RegistrationPost.class` estiver sendo usada**.

Da mesma forma, no m√©todo `updateUser`:
```java
@RequestBody @JsonView(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Isso indica que **apenas os campos marcados com `UserPut` ser√£o desserializados do JSON enviado no request**.

---

### üöÄ **Resumindo**
1. **`@Validated`** ‚Üí Aplica **valida√ß√µes condicionais** dependendo do grupo especificado no request.
2. **`@JsonView`** ‚Üí Controla **quais campos aparecem na requisi√ß√£o e resposta**, dependendo da view definida.

Isso permite maior flexibilidade, garantindo que **diferentes endpoints apliquem regras e retornem apenas os dados necess√°rios**.


-- JPA,  SPRING DATA JPA e HIBERNATE --

N√£o exatamente. **Spring Data JPA e Hibernate n√£o s√£o duas abstra√ß√µes do JPA**, mas sim tecnologias diferentes que interagem com ele de maneiras distintas.

---

## üîπ **JPA (Java Persistence API)**
JPA √© apenas uma **especifica√ß√£o** (ou seja, um conjunto de interfaces e regras) para gerenciamento de persist√™ncia em Java.  
Ele define como as entidades devem ser mapeadas para o banco de dados, mas **n√£o implementa nada por si s√≥**.

üëâ Para usar JPA, √© necess√°rio um **provedor de persist√™ncia** que implemente essa especifica√ß√£o. √â a√≠ que entra o Hibernate.

---

## üîπ **Hibernate**
O **Hibernate** √© a implementa√ß√£o **mais popular** do JPA. Ele fornece:
‚úî Um provedor de persist√™ncia JPA.  
‚úî Recursos extras al√©m do que o JPA especifica.  
‚úî Funcionalidades avan√ßadas como caching, lazy loading otimizado e query caching.

Ou seja, **Hibernate √© um ORM (Object-Relational Mapping) que implementa JPA**.  

‚û° Voc√™ pode usar Hibernate diretamente sem JPA, mas o ideal √© usar JPA para manter seu c√≥digo mais gen√©rico e desacoplado da implementa√ß√£o.

---

## üîπ **Spring Data JPA**
O **Spring Data JPA** √© uma **abstra√ß√£o sobre o JPA** que simplifica o uso do JPA/Hibernate no Spring. Ele fornece:
‚úî Implementa√ß√£o autom√°tica de reposit√≥rios (`JpaRepository`, `CrudRepository`).  
‚úî M√©todos de consulta personalizados sem precisar escrever SQL (`findByEmail`, `findByNameContaining`).  
‚úî Integra√ß√£o f√°cil com o **Spring Boot**.  
‚úî Redu√ß√£o dr√°stica da quantidade de c√≥digo boilerplate.

‚ö° **Ou seja:** O Spring Data JPA usa o JPA (e, indiretamente, o Hibernate) para facilitar a persist√™ncia.

---

## üéØ **Resumindo a Diferen√ßa**
| Tecnologia        | O que √©? | Implementa√ß√£o |
|------------------|---------|---------------|
| **JPA**          | Especifica√ß√£o (interfaces e regras) | N√£o tem implementa√ß√£o pr√≥pria |
| **Hibernate**    | ORM que implementa JPA | Sim, √© um provedor de persist√™ncia |
| **Spring Data JPA** | Abstra√ß√£o do JPA dentro do Spring | Usa JPA e um provedor como Hibernate |

üîπ **JPA** define as regras.  
üîπ **Hibernate** implementa essas regras.  
üîπ **Spring Data JPA** facilita o uso do JPA e do Hibernate no Spring.

Se estiver usando **Spring Boot**, o Hibernate √© o provedor padr√£o do Spring Data JPA, ent√£o ao configurar um banco, ele j√° ser√° utilizado automaticamente. üöÄ

No **Hibernate** e **Spring Data JPA**, h√° v√°rias formas de realizar consultas no banco de dados. A escolha da abordagem depende da complexidade da consulta e do n√≠vel de abstra√ß√£o desejado.  

---

## üîπ **1. Consultas Usando M√©todos de Interface (`Derived Query Methods`)**  
O **Spring Data JPA** permite definir consultas diretamente no nome do m√©todo da interface do reposit√≥rio.  

### ‚úÖ Exemplo:
```java
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByUsername(String username);
    List<User> findByEmailContaining(String emailPart);
    List<User> findByCreatedAtAfter(LocalDateTime date);
}
```
üìå **Como funciona?** O Spring analisa o nome do m√©todo, gera automaticamente a consulta e a executa.  
‚úî F√°cil de usar, mas limitado a consultas mais simples.  

---

## üîπ **2. Consultas Usando `@Query` (JPQL ou SQL Nativo)**
Para consultas mais complexas, podemos usar **JPQL** (Java Persistence Query Language) ou SQL nativo.

### ‚úÖ **JPQL (Java Persistence Query Language)**
JPQL √© semelhante ao SQL, mas opera sobre **entidades e atributos**, n√£o sobre tabelas e colunas.  

```java
@Query("SELECT u FROM User u WHERE u.email = :email")
User findByEmail(@Param("email") String email);
```

### ‚úÖ **SQL Nativo**
Se precisar de uma consulta mais otimizada diretamente no banco, pode usar **SQL puro**:  

```java
@Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
User findByEmailNative(@Param("email") String email);
```

üìå **JPQL √© mais port√°til**, enquanto **SQL nativo pode ser mais perform√°tico** dependendo do banco de dados.

---

## üîπ **3. Consultas Usando `EntityManager` e `Criteria API`**
Se precisar de mais flexibilidade, pode usar o `EntityManager` para criar queries din√¢micas.  

### ‚úÖ **Usando `EntityManager` (JPQL)**
```java
@Autowired
private EntityManager entityManager;

public List<User> findUsersCreatedAfter(LocalDateTime date) {
    String jpql = "SELECT u FROM User u WHERE u.createdAt > :date";
    return entityManager.createQuery(jpql, User.class)
                        .setParameter("date", date)
                        .getResultList();
}
```

### ‚úÖ **Usando `Criteria API` (Consulta Din√¢mica)**
A Criteria API permite construir consultas dinamicamente, √∫til para filtros flex√≠veis.  

```java
public List<User> findUsersByCriteria(String username, String email) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> cq = cb.createQuery(User.class);
    Root<User> user = cq.from(User.class);

    List<Predicate> predicates = new ArrayList<>();
    if (username != null) {
        predicates.add(cb.equal(user.get("username"), username));
    }
    if (email != null) {
        predicates.add(cb.like(user.get("email"), "%" + email + "%"));
    }
    
    cq.where(predicates.toArray(new Predicate[0]));
    return entityManager.createQuery(cq).getResultList();
}
```

üìå **Vantagem da Criteria API** ‚Üí Boa para **constru√ß√£o din√¢mica** de consultas sem manipular strings manualmente.

---

## üîπ **4. Consultas Usando `Specification` (Spring Data JPA)**
Para consultas din√¢micas e reutiliz√°veis, o Spring oferece a interface `Specification<T>`, baseada na **Criteria API**.

### ‚úÖ **Exemplo de `Specification`**
```java
public class UserSpecification {
    public static Specification<User> hasUsername(String username) {
        return (root, query, cb) -> cb.equal(root.get("username"), username);
    }

    public static Specification<User> emailContains(String email) {
        return (root, query, cb) -> cb.like(root.get("email"), "%" + email + "%");
    }
}
```
Agora podemos combinar as condi√ß√µes dinamicamente:

```java
List<User> users = userRepository.findAll(Specification
        .where(UserSpecification.hasUsername("john"))
        .and(UserSpecification.emailContains("@gmail.com")));
```
üìå **√ìtimo para filtros din√¢micos e complexos!**  

---

## üîπ **5. Consultas Usando `NamedQuery`**
Podemos definir queries diretamente na entidade.

### ‚úÖ **Exemplo**
```java
@Entity
@NamedQuery(name = "User.findByEmail", query = "SELECT u FROM User u WHERE u.email = :email")
public class User { ... }
```
E no reposit√≥rio:
```java
User user = userRepository.findByEmail("test@example.com");
```

üìå **√ötil para reuso de queries, mas menos flex√≠vel que `@Query` ou Criteria API.**

---

## üéØ **Resumo das Formas de Consulta**
| M√©todo | Caracter√≠sticas | Melhor para |
|--------|---------------|-------------|
| **Derived Queries** (`findByUsername`) | Baseado no nome do m√©todo, sem SQL | Consultas simples |
| **JPQL (`@Query`)** | Usa linguagem baseada em entidades | Consultas intermedi√°rias |
| **SQL Nativo (`@Query(nativeQuery = true)`)** | SQL puro, mais perform√°tico | Consultas espec√≠ficas do banco |
| **EntityManager (JPQL ou Criteria API)** | Total controle da query | Consultas complexas e din√¢micas |
| **Specification API** | Combina filtros dinamicamente | Filtros avan√ßados e reutiliz√°veis |
| **NamedQuery** | Definido na entidade, reutiliz√°vel | Queries fixas |

Se precisar de algo **r√°pido e simples**, `Derived Queries` e `@Query` s√£o boas op√ß√µes.  
Se precisar de algo **din√¢mico**, `Criteria API` ou `Specification` s√£o mais adequados. üöÄ



--  API Specification -- 

Esse c√≥digo usa a **Specification API** do Spring Data JPA, combinada com a biblioteca **Spring Specification Argument Resolver**, para permitir que a API filtre usu√°rios dinamicamente com base nos par√¢metros enviados na requisi√ß√£o.  

Vamos analisar os trechos de c√≥digo:

---

## **1Ô∏è‚É£ M√©todo `getAllUsers`**
```java
@GetMapping
public ResponseEntity<Page<UserModel>> getAllUsers(SpecificationTemplate.UserSpec spec, Pageable pageable){
    Page<UserModel> userModelPage = userService.findAll(spec, pageable);
    
    if(!userModelPage.isEmpty()){
        for(UserModel user : userModelPage.toList()){
            user.add(linkTo(methodOn(UserController.class).getOneUser(user.getUserId())).withSelfRel());
        }
    }
    
    return ResponseEntity.status(HttpStatus.OK).body(userModelPage);
}
```
### üîπ O que esse m√©todo faz?
- **Recebe uma requisi√ß√£o `GET` para buscar usu√°rios**.
- **Aceita filtros din√¢micos** via `SpecificationTemplate.UserSpec` (explicado na pr√≥xima se√ß√£o).
- **Aceita pagina√ß√£o** via `Pageable` (Spring Data JPA suporta pagina√ß√£o autom√°tica).
- **Chama `userService.findAll(spec, pageable)`**, que retorna os usu√°rios filtrados e paginados.
- **Adiciona links HATEOAS** aos usu√°rios para facilitar navega√ß√£o na API REST.
- **Retorna os resultados com c√≥digo HTTP 200 (OK)**.

---

## **2Ô∏è‚É£ `SpecificationTemplate` - Criando Filtros Din√¢micos**
```java
public class SpecificationTemplate {

    @And({
            @Spec(path = "userType", spec = Equal.class),
            @Spec(path = "userStatus", spec = Equal.class),
            @Spec(path = "email", spec = Like.class),
            @Spec(path = "username", spec = Like.class),
            @Spec(path = "fullName", spec = LikeIgnoreCase.class)
    })
    public interface UserSpec extends Specification<UserModel> {}
}
```

### üîπ O que essa classe faz?
Ela define um conjunto de **especifica√ß√µes din√¢micas** para que os usu√°rios possam ser filtrados atrav√©s de par√¢metros na URL.

- **`@And({...})`** ‚Üí Indica que todas as condi√ß√µes dentro dela podem ser combinadas.
- **`@Spec(path = "...", spec = Tipo.class)`** ‚Üí Define a regra de filtragem para cada campo:
  - `Equal.class` ‚Üí Busca valores **exatamente iguais** (`userType`, `userStatus`).
  - `Like.class` ‚Üí Busca valores **contendo um trecho do texto** (`email`, `username`).
  - `LikeIgnoreCase.class` ‚Üí Busca valores **contendo um trecho do texto, ignorando mai√∫sculas/min√∫sculas** (`fullName`).

### üîπ Como usar na requisi√ß√£o?
Como essa interface estende `Specification<UserModel>`, o Spring Data JPA consegue processar automaticamente os par√¢metros da URL para realizar as consultas.

‚úÖ **Exemplo de requisi√ß√£o GET com filtros din√¢micos:**
```http
GET /users?username=john&email=@gmail.com
```
üîπ Isso resultaria em uma consulta SQL equivalente a:
```sql
SELECT * FROM users 
WHERE username LIKE '%john%' 
AND email LIKE '%@gmail.com%'
```

---

## **3Ô∏è‚É£ Como Funciona o `findAll(spec, pageable)`?**
A chamada `userService.findAll(spec, pageable)` dentro do m√©todo `getAllUsers` retorna os usu√°rios filtrados e paginados.

### **No `UserService`:**
```java
public Page<UserModel> findAll(Specification<UserModel> spec, Pageable pageable) {
    return userRepository.findAll(spec, pageable);
}
```
### **No `UserRepository`:**
```java
public interface UserRepository extends JpaRepository<UserModel, UUID>, JpaSpecificationExecutor<UserModel> {}
```
üìå **A interface `JpaSpecificationExecutor` permite consultas din√¢micas usando `Specification<T>`**.

---

## **üî• Resumo Geral**
‚úî **Filtragem Din√¢mica**: Os usu√°rios podem ser filtrados por qualquer combina√ß√£o de par√¢metros na URL.  
‚úî **Uso de Specification API**: Permite consultas flex√≠veis sem necessidade de escrever queries SQL.  
‚úî **Pagina√ß√£o Autom√°tica**: O `Pageable` facilita a implementa√ß√£o de pagina√ß√£o.  
‚úî **HATEOAS**: Links s√£o adicionados a cada usu√°rio, facilitando a navega√ß√£o na API REST.  

Esse padr√£o √© muito √∫til para construir APIs REST escal√°veis e flex√≠veis. üöÄ

-- Annotation @PasswordConstraint --

A annotation `@PasswordConstraint` no seu c√≥digo √© uma **valida√ß√£o personalizada** utilizada para garantir que a senha atenda a crit√©rios espec√≠ficos. Ela √© aplicada nos campos `password` e `oldPassword` do `UserRecordDto` e faz parte da **Bean Validation API (Jakarta Validation, antiga Javax Validation)**, integrada ao Spring Boot.  

---

## **1Ô∏è‚É£ Onde a annotation √© usada?**
No DTO (`UserRecordDto`), voc√™ usa `@PasswordConstraint` para validar os campos `password` e `oldPassword`:

```java
@PasswordConstraint(groups = {UserView.RegistrationPost.class, UserView.PasswordPut.class})
@JsonView({UserView.RegistrationPost.class, UserView.PasswordPut.class})
String password;
```

Isso significa que:
- Quando um usu√°rio se registra ou atualiza a senha (`RegistrationPost` ou `PasswordPut`), a senha precisa passar pela valida√ß√£o definida em `@PasswordConstraint`.

---

## **2Ô∏è‚É£ Como `@PasswordConstraint` foi criada?**
Essa annotation personalizada geralmente √© implementada com duas partes:  
1. **A annotation (`@interface PasswordConstraint`)**  
2. **O validador (`PasswordConstraintValidator`)**

---

### **üìå 1. Criando a annotation personalizada**
```java
import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Constraint(validatedBy = PasswordConstraintValidator.class)  // Define a classe que implementa a l√≥gica da valida√ß√£o
@Target({ ElementType.FIELD })  // Pode ser usada apenas em campos
@Retention(RetentionPolicy.RUNTIME)  // A annotation ser√° verificada em tempo de execu√ß√£o
public @interface PasswordConstraint {
    
    String message() default "Password does not meet the security requirements"; // Mensagem de erro padr√£o
    
    Class<?>[] groups() default {};  // Permite agrupar valida√ß√µes para diferentes cen√°rios
    
    Class<? extends Payload>[] payload() default {};  // Metadados adicionais (geralmente n√£o s√£o utilizados)
}
```

**Explica√ß√£o:**  
‚úî `@Constraint(validatedBy = PasswordConstraintValidator.class)`: Define a classe respons√°vel por validar a senha.  
‚úî `@Target(ElementType.FIELD)`: Indica que a annotation pode ser usada em atributos de classe.  
‚úî `@Retention(RetentionPolicy.RUNTIME)`: Garante que a valida√ß√£o seja aplicada durante a execu√ß√£o da aplica√ß√£o.  
‚úî `String message() default "..."`: Define a mensagem de erro que ser√° exibida caso a valida√ß√£o falhe.  
‚úî `Class<?>[] groups() default {}`: Permite que a valida√ß√£o seja aplicada em contextos espec√≠ficos (como `RegistrationPost` e `PasswordPut`).  
‚úî `Class<? extends Payload>[] payload() default {}`: Pode ser usado para carregar metadados adicionais.

---

### **üìå 2. Criando o Validador (`PasswordConstraintValidator`)**
A annotation sozinha n√£o faz nada. Precisamos implementar a l√≥gica da valida√ß√£o em uma classe separada.

```java
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

public class PasswordConstraintValidator implements ConstraintValidator<PasswordConstraint, String> {

    @Override
    public void initialize(PasswordConstraint constraintAnnotation) {
        // M√©todo opcional: pode ser usado para inicializar configura√ß√µes
    }

    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;  // Senha n√£o pode ser nula
        }

        // Crit√©rios da senha (exemplo: m√≠nimo 8 caracteres, 1 mai√∫scula, 1 n√∫mero e 1 caractere especial)
        return password.matches("^(?=.*[A-Z])(?=.*\\d)(?=.*[@#$%^&+=]).{8,}$");
    }
}
```

**Explica√ß√£o:**  
‚úî `implements ConstraintValidator<PasswordConstraint, String>` ‚Üí Diz que essa classe validar√° `String` com a regra de `@PasswordConstraint`.  
‚úî `isValid(String password, ConstraintValidatorContext context)` ‚Üí Implementa a l√≥gica da valida√ß√£o:  
   - **Se a senha for nula, retorna `false`** (senha obrigat√≥ria).  
   - **Se a senha n√£o seguir o regex, retorna `false`**.  
   - **O regex exige:**  
     üîπ Pelo menos **8 caracteres**  
     üîπ Pelo menos **1 letra mai√∫scula**  
     üîπ Pelo menos **1 n√∫mero**  
     üîπ Pelo menos **1 caractere especial** (@, #, $, %, ^, &, +, =)  

---

## **3Ô∏è‚É£ Como a valida√ß√£o acontece?**
Quando um usu√°rio tenta registrar ou atualizar a senha, o Spring Boot automaticamente valida os dados do DTO antes de continuar o fluxo da requisi√ß√£o.

### **Exemplo de requisi√ß√£o JSON**
#### üî¥ **Requisi√ß√£o inv√°lida (sem n√∫mero e caractere especial)**
```json
{
  "username": "john_doe",
  "email": "john.doe@example.com",
  "password": "Password"
}
```
üîπ **Resposta da API (HTTP 400 - Bad Request)**  
```json
{
  "password": "Password does not meet the security requirements"
}
```

#### ‚úÖ **Requisi√ß√£o v√°lida**
```json
{
  "username": "john_doe",
  "email": "john.doe@example.com",
  "password": "Pa$$w0rd"
}
```
üîπ **Resposta da API (HTTP 201 - Created)**  
```json
{
  "message": "User created successfully"
}
```

---

## **üî• Resumo Geral**
‚úî `@PasswordConstraint` √© uma annotation personalizada que valida a senha.  
‚úî Ela √© usada no DTO para aplicar regras de valida√ß√£o nos campos `password` e `oldPassword`.  
‚úî A annotation est√° vinculada ao validador `PasswordConstraintValidator`, que implementa a l√≥gica da valida√ß√£o.  
‚úî O Spring Boot executa a valida√ß√£o automaticamente antes de processar a requisi√ß√£o.  

Esse √© um √≥timo exemplo de **boas pr√°ticas** no Spring Boot, garantindo **seguran√ßa** e **flexibilidade** ao sistema. üöÄ


-- HATEOAS --

Sim, essa linha est√° relacionada ao conceito de **HATEOAS (Hypermedia as the Engine of Application State)**, que √© um dos princ√≠pios do **REST**.

A ideia por tr√°s do HATEOAS √© que uma API REST deve ser capaz de fornecer links para recursos relacionados, permitindo que o cliente navegue pela API de forma autossuficiente, sem necessidade de documenta√ß√£o adicional, a partir dos links fornecidos nas respostas.

### Explicando a linha

```java
user.add(linkTo(methodOn(UserController.class).getOneUser(user.getUserId())).withSelfRel());
```

Aqui est√° o que est√° acontecendo:

1. **`linkTo()`**: Esse m√©todo √© usado para gerar um link para um recurso. Ele √© parte da biblioteca **Spring HATEOAS** e √© uma forma de criar links de maneira din√¢mica, sem precisar escrever URLs de forma manual.

2. **`methodOn(UserController.class)`**: Este √© um m√©todo de apoio que cria um proxy para o controlador `UserController`. Ele √© usado para gerar links para os m√©todos do controlador sem precisar chamar o m√©todo diretamente (o que √© √∫til para evitar hardcoding de URLs).

3. **`getOneUser(user.getUserId())`**: Aqui, voc√™ est√° chamando o m√©todo `getOneUser` do controlador `UserController` passando o `user.getUserId()` como par√¢metro. Esse m√©todo provavelmente √© respons√°vel por retornar um usu√°rio espec√≠fico baseado no seu ID.

4. **`withSelfRel()`**: Esse m√©todo adiciona um link "self" √† entidade `user`. O link "self" √© um link para o pr√≥prio recurso, ou seja, um link que aponta para a representa√ß√£o do pr√≥prio recurso (o usu√°rio neste caso). O HATEOAS recomenda que cada recurso tenha um link "self" que permita ao cliente acessar o pr√≥prio recurso diretamente.

### Resultado

Ao executar essa linha, voc√™ est√° adicionando um link auto-referencial ("self") √† entidade `user`. O cliente poder√° ent√£o seguir esse link para obter mais informa√ß√µes sobre o pr√≥prio usu√°rio, como se estivesse navegando pela API.

O HATEOAS melhora a navegabilidade da API, tornando-a mais "descoberta" pelo cliente, j√° que ele pode, por exemplo, seguir os links que a API fornece para acessar outros recursos relacionados sem ter que saber previamente os URLs exatos.


-- Performance com Hibernate --

O **Hibernate** lida com diferentes tipos de cole√ß√µes (`Set`, `List`, `Map`, etc.) de maneiras distintas, e essas diferen√ßas podem afetar o desempenho da aplica√ß√£o de forma significativa. Essas cole√ß√µes s√£o usadas em entidades como **relacionamentos** entre objetos, e o Hibernate oferece estrat√©gias de mapeamento e gerenciamento de dados diferentes para cada tipo de cole√ß√£o.

### Diferen√ßas de como o Hibernate lida com cole√ß√µes

1. **`List` (Lista ordenada):**
   - **Comportamento:** Uma `List` em Java mant√©m a ordem dos elementos. No Hibernate, a cole√ß√£o `List` √© tipicamente mapeada com um **√≠ndice** para garantir a ordem dos elementos.
   - **Estrat√©gia de Mapeamento:** Para garantir a ordem, o Hibernate normalmente cria uma **tabela de associa√ß√£o** extra (caso seja um relacionamento entre entidades) ou utiliza um campo de √≠ndice diretamente na tabela principal para controlar a ordem dos itens.
   - **Desempenho:** A utiliza√ß√£o de `List` pode impactar o desempenho quando o n√∫mero de elementos for grande, pois o Hibernate precisa garantir a ordem, o que pode envolver o uso de √≠ndices ou de tabelas extras para armazenar a posi√ß√£o dos itens.

2. **`Set` (Conjunto, sem ordem):**
   - **Comportamento:** O `Set` n√£o garante uma ordem, o que significa que os elementos s√£o armazenados de forma n√£o ordenada. O Hibernate pode usar uma **tabela de associa√ß√£o** simples ou fazer uso de **chaves prim√°rias compostas** para representar os elementos.
   - **Estrat√©gia de Mapeamento:** O Hibernate, para o `Set`, utiliza **mapeamento de associa√ß√£o simples** e, muitas vezes, n√£o cria √≠ndices ou outras estruturas extras, pois a ordem n√£o √© relevante.
   - **Desempenho:** O `Set` tende a ser mais eficiente do que a `List` em termos de desempenho porque n√£o precisa de gerenciamento de √≠ndices ou de manter a ordem. No entanto, o Hibernate ainda cria uma tabela de associa√ß√£o ou usa `JOIN` para buscar os dados relacionados, o que pode ter impacto dependendo do n√∫mero de registros e do tipo de relacionamento (ex.: `ManyToMany`).

3. **`Map` (Mapa de chave-valor):**
   - **Comportamento:** O `Map` armazena pares de chave-valor. Em um relacionamento de banco de dados, isso geralmente implica em uma tabela de associa√ß√£o com uma chave √∫nica (geralmente a chave do objeto) e um valor associado.
   - **Estrat√©gia de Mapeamento:** O Hibernate pode mapear `Map` de v√°rias maneiras, mas, frequentemente, usa uma **tabela de associa√ß√£o** que inclui a chave e o valor como colunas distintas. Ou seja, a chave do `Map` geralmente mapeia para uma coluna de chave estrangeira na tabela, e o valor pode ser mapeado como outro tipo de dado.
   - **Desempenho:** O uso de `Map` pode ser mais pesado do que `Set` ou `List`, pois implica que o Hibernate precisa de uma tabela de associa√ß√£o com dois campos: um para a chave e outro para o valor. No entanto, a escolha de `Map` pode ser vantajosa quando voc√™ realmente precisa associar valores a chaves espec√≠ficas.

4. **`Queue` (Fila):**
   - **Comportamento:** Embora n√£o seja um tipo de cole√ß√£o t√£o comum em mapeamentos ORM, o `Queue` √© um tipo de cole√ß√£o que pode ser mapeado usando a estrat√©gia de **`List`**, com o controle da ordem de inser√ß√£o. A diferen√ßa √© que o `Queue` pode ser mais eficiente para cen√°rios em que √© necess√°rio inserir/remover elementos em uma ordem espec√≠fica (FIFO).
   - **Estrat√©gia de Mapeamento:** Geralmente, o `Queue` √© mapeado de forma semelhante a uma `List`, mas com as opera√ß√µes que precisam ser otimizadas para inser√ß√µes e remo√ß√µes no final ou in√≠cio da cole√ß√£o.
   - **Desempenho:** O desempenho depende do tipo de fila e da implementa√ß√£o utilizada. Para muitos elementos e opera√ß√µes frequentes de inser√ß√£o e remo√ß√£o, o desempenho pode ser impactado pela estrat√©gia de mapeamento.

### Diferen√ßas de Performance: `Set`, `List`, e `Map` em Hibernate

1. **`Set` vs. `List`:**
   - **`Set`** √© mais r√°pido do que `List` porque n√£o exige o gerenciamento de √≠ndices. O Hibernate n√£o precisa criar ou manter √≠ndices ou fazer ordens espec√≠ficas de busca, j√° que os elementos s√£o apenas armazenados sem qualquer ordem.
   - **`List`** envolve um controle extra de √≠ndice, o que pode levar a **consultas mais complexas** ou a maior sobrecarga para manter a ordem dos elementos.
   - **Cen√°rio de Desempenho:** Em um cen√°rio de relacionamento `ManyToMany`, o `Set` pode ser mais eficiente para grandes quantidades de dados, j√° que n√£o h√° necessidade de uma estrutura de √≠ndice extra. O `List`, por sua vez, pode ser mais lento por causa dessa estrutura adicional.

2. **`Set` vs. `Map`:**
   - **`Set`** n√£o precisa armazenar a chave e o valor, como acontece em um `Map`. Isso significa que a sobrecarga de mapeamento em um `Map` √© geralmente mais alta, especialmente se voc√™ tiver que realizar `JOINs` adicionais ou ter um relacionamento mais complexo.
   - **`Map`** pode ser mais eficiente quando voc√™ precisa associar dados a uma chave, mas, em termos de desempenho, isso pode ser mais caro em termos de leitura e escrita de dados, especialmente se voc√™ precisar de opera√ß√µes de busca baseadas na chave.
   - **Cen√°rio de Desempenho:** Se o relacionamento entre as entidades for simples e voc√™ precisar apenas de um conjunto de dados sem chaves espec√≠ficas, o `Set` √© mais eficiente. Caso contr√°rio, quando uma associa√ß√£o de chave-valor for necess√°ria, o `Map` pode ser mais adequado, mas com a trade-off de maior sobrecarga.

### Considera√ß√µes de Desempenho

- **Consulta e Recupera√ß√£o de Dados:** Se voc√™ tiver um grande n√∫mero de registros, a estrat√©gia de **fetching** (como **Lazy** vs **Eager**) pode afetar o desempenho. Para **Lazy Loading**, o Hibernate vai buscar os dados associados **somente quando necess√°rio**, enquanto **Eager Loading** pode resultar em consultas mais pesadas com **JOINs** ou m√∫ltiplas consultas ao banco de dados.
  
- **Cache de N√≠vel 1 e 2:** O uso de caches de **n√≠vel 1** (sess√£o) e **n√≠vel 2** (acima da sess√£o) pode afetar o desempenho ao acessar dados que j√° foram carregados anteriormente, independentemente do tipo de cole√ß√£o que voc√™ estiver usando.

- **Tamanho das Cole√ß√µes:** Para **grandes cole√ß√µes**, como aquelas mapeadas com `List` ou `Set`, o **uso de √≠ndices** nas tabelas de associa√ß√£o pode ser crucial para otimizar o desempenho das consultas, especialmente quando voc√™ est√° lidando com muitas entidades relacionadas.

### Conclus√£o

- **`Set`** tende a ser o mais eficiente em termos de desempenho devido √† falta de ordena√ß√£o e sobrecarga de √≠ndice.
- **`List`** tem um desempenho mais lento por causa da necessidade de manter a ordem, o que pode envolver opera√ß√µes de √≠ndice extras.
- **`Map`** pode ser mais caro em termos de desempenho por causa do mapeamento de chave-valor e, em casos de relacionamentos complexos, pode envolver **JOINs** adicionais.
  
O uso de **Lazy Loading** ou **Eager Loading**, o **tamanho das cole√ß√µes** e a necessidade de **consultas complexas** s√£o fatores importantes a considerar ao escolher o tipo de cole√ß√£o no Hibernate.

O impacto de **Lazy Loading** e **Eager Loading** no desempenho de uma aplica√ß√£o utilizando Hibernate depende diretamente de como os dados relacionados s√£o carregados e do tipo de cole√ß√£o sendo utilizada (como `List`, `Set`, `Map`, etc.). Esses dois modos de carregamento determinam como o Hibernate lida com as associa√ß√µes de entidades, ou seja, como ele carrega as cole√ß√µes de dados associadas a uma entidade quando a consulta √© realizada.

### **Lazy Loading** e **Eager Loading**

- **Lazy Loading**: Significa que o Hibernate carrega as associa√ß√µes **somente quando necess√°rio**. Ou seja, quando voc√™ acessa um atributo de uma entidade que est√° marcado para lazy loading (carregamento pregui√ßoso), o Hibernate ir√° fazer uma nova consulta ao banco de dados para carregar esses dados. Isso √© √∫til para **evitar consultas desnecess√°rias**, especialmente se voc√™ n√£o precisa das cole√ß√µes imediatamente.

- **Eager Loading**: Significa que o Hibernate carrega as associa√ß√µes **imediatamente** junto com a consulta principal, ou seja, no momento em que voc√™ carrega a entidade, todas as cole√ß√µes associadas tamb√©m s√£o carregadas. Isso pode resultar em **consultas maiores e mais pesadas**, j√° que o Hibernate precisa carregar os dados de todas as associa√ß√µes de uma vez.

### Impacto do **Lazy Loading** e **Eager Loading** em Cole√ß√µes

#### 1. **`List` (Lista Ordenada)**
   - **Lazy Loading**: Com **Lazy Loading** em uma `List`, o Hibernate s√≥ ir√° carregar a cole√ß√£o (lista) quando voc√™ acessar o m√©todo que a retorna (por exemplo, `getItems()`). Se voc√™ tiver uma grande lista e acessar ela v√°rias vezes, isso pode causar v√°rias consultas ao banco de dados, o que pode ser um problema de desempenho se voc√™ acessar a lista muitas vezes.
     - **Impacto**: Muitas consultas subsequentes podem levar a um grande n√∫mero de **consultas N+1** (quando voc√™ carrega a entidade principal e depois uma consulta separada para cada item da lista).
   - **Eager Loading**: Com **Eager Loading**, o Hibernate ir√° carregar todos os itens da lista no momento em que a entidade principal for carregada. Isso pode ser mais eficiente se voc√™ precisar de toda a lista ao mesmo tempo, evitando v√°rias consultas, mas pode sobrecarregar a consulta, especialmente se a lista contiver muitos itens.
     - **Impacto**: A consulta inicial ser√° mais pesada e pode retornar muitos dados desnecess√°rios caso voc√™ n√£o precise de todos os itens da lista.

#### 2. **`Set` (Conjunto)**
   - **Lazy Loading**: Em um `Set`, o Hibernate carregar√° a cole√ß√£o de elementos somente quando voc√™ acessar a cole√ß√£o pela primeira vez. Isso √© eficiente porque evita o carregamento de dados desnecess√°rios, especialmente se o n√∫mero de elementos no `Set` for grande e voc√™ n√£o precisar de todos os elementos de imediato.
     - **Impacto**: Embora seja eficiente em termos de **uso de mem√≥ria e tempo de resposta inicial**, o acesso √† cole√ß√£o no futuro pode gerar **consultas adicionais** ao banco de dados, o que pode ser um problema em cen√°rios de alta carga e grandes volumes de dados.
   - **Eager Loading**: Com **Eager Loading**, o Hibernate carrega todos os elementos do `Set` na mesma consulta inicial. Isso pode ser √∫til quando voc√™ sabe que precisar√° de todos os elementos, mas pode resultar em sobrecarga se o conjunto for muito grande ou se voc√™ n√£o precisar de todos os dados logo de cara.
     - **Impacto**: Pode sobrecarregar a consulta inicial e prejudicar o desempenho em cen√°rios onde a cole√ß√£o cont√©m muitos itens desnecess√°rios.

#### 3. **`Map` (Chave-Valor)**
   - **Lazy Loading**: Para um `Map`, o Hibernate s√≥ ir√° carregar os valores do `Map` quando voc√™ acessar a cole√ß√£o. Isso pode ser √∫til para evitar sobrecarga, mas o `Map` pode envolver m√∫ltiplas chaves e valores, o que pode resultar em consultas adicionais dependendo da implementa√ß√£o.
     - **Impacto**: Se voc√™ acessar frequentemente as chaves e valores de forma indiscriminada, isso pode gerar muitas consultas, o que afeta o desempenho.
   - **Eager Loading**: Com **Eager Loading**, o `Map` √© carregado junto com a entidade principal, incluindo todos os pares chave-valor. Isso pode resultar em um desempenho mais consistente quando voc√™ precisa de todos os dados, mas tamb√©m pode ser ineficiente em termos de tempo de execu√ß√£o e uso de mem√≥ria.
     - **Impacto**: O carregamento de todos os pares chave-valor pode ser extremamente ineficiente se o `Map` contiver muitos dados que voc√™ n√£o vai precisar no momento.

### **Efeitos no Desempenho**

#### **Lazy Loading**
- **Vantagens**:
  - **Consultas menores**: Carrega os dados sob demanda, o que pode ser mais eficiente se voc√™ n√£o precisar acessar as cole√ß√µes imediatamente.
  - **Menos dados carregados**: Apenas os dados necess√°rios s√£o carregados da base de dados.
- **Desvantagens**:
  - **Consultas N+1**: Se voc√™ acessar v√°rias cole√ß√µes relacionadas dentro de um loop ou em um cen√°rio de m√∫ltiplas entidades relacionadas, voc√™ pode acabar executando v√°rias consultas adicionais ao banco de dados, o que impacta negativamente o desempenho.
  - **Complexidade adicional**: Voc√™ precisa ter cuidado com o **LazyInitializationException**, que ocorre quando a sess√£o √© fechada antes que o Hibernate possa carregar a cole√ß√£o `lazy`.

#### **Eager Loading**
- **Vantagens**:
  - **Consultas mais r√°pidas**: Quando voc√™ sabe que precisar√° de todas as cole√ß√µes de uma vez, o **Eager Loading** evita consultas adicionais ao carregar todos os dados de uma vez.
  - **Evita N+1**: Como os dados s√£o carregados de uma vez, o problema de **N+1 queries** √© evitado.
- **Desvantagens**:
  - **Consultas pesadas**: Se voc√™ carregar muitas cole√ß√µes ou uma grande quantidade de dados desnecess√°rios, isso pode resultar em uma consulta muito pesada, o que impacta o tempo de resposta e o uso de mem√≥ria.
  - **Desempenho e uso de mem√≥ria**: A sobrecarga de carregar muitos dados de uma vez pode resultar em um uso de mem√≥ria maior e diminuir a performance em cen√°rios com grandes volumes de dados.

### **Considera√ß√µes de Desempenho em Diferentes Cen√°rios**

1. **Consultas com poucas associa√ß√µes**:
   - Se voc√™ tem poucas associa√ß√µes ou cole√ß√µes pequenas, o **Eager Loading** pode ser eficiente, pois voc√™ carrega tudo de uma vez e evita m√∫ltiplas consultas. No entanto, se a quantidade de dados for significativa, o **Lazy Loading** pode ser mais eficiente.

2. **Consultas com muitas associa√ß√µes**:
   - Se voc√™ estiver lidando com muitas associa√ß√µes, especialmente cole√ß√µes grandes, o **Lazy Loading** ser√° mais vantajoso em termos de desempenho, porque voc√™ evita carregar todos os dados de uma vez. No entanto, isso pode gerar **N+1 queries**, o que deve ser tratado com **fetch joins** ou **DTOs** para mitigar o problema.

3. **Exibi√ß√£o de dados na interface**:
   - Se voc√™ precisa de todos os dados de uma vez (por exemplo, na exibi√ß√£o de uma p√°gina com todas as cole√ß√µes), o **Eager Loading** pode ser uma boa op√ß√£o, pois evita consultas adicionais. Caso contr√°rio, o **Lazy Loading** pode ser mais eficiente, especialmente em **situa√ß√µes de navega√ß√£o e pagina√ß√£o**.

### Conclus√£o

- **Lazy Loading** √© geralmente mais eficiente quando voc√™ tem grandes volumes de dados e n√£o precisa carregar todas as cole√ß√µes de uma vez, mas voc√™ precisa tomar cuidado com o problema de **consultas N+1** e **LazyInitializationException**.
- **Eager Loading** pode ser √∫til quando voc√™ sabe que precisa de todos os dados de uma vez, mas pode causar **consultas pesadas** e **uso excessivo de mem√≥ria**, especialmente quando h√° grandes cole√ß√µes.

A escolha entre **Lazy Loading** e **Eager Loading** deve ser feita considerando o **cen√°rio espec√≠fico de uso** e as **necessidades de desempenho** da aplica√ß√£o.

-- Preven√ß√£o de Ref. Ciclica -- 

A anota√ß√£o `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` √© usada para controlar a serializa√ß√£o e desserializa√ß√£o de propriedades em objetos, especialmente quando voc√™ deseja controlar como uma propriedade ser√° manipulada durante o processo de convers√£o entre objetos Java e JSON.

### Significado de `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`:

- **`WRITE_ONLY`**: Essa configura√ß√£o indica que a propriedade ser√° **apenas gravada (escrita)** durante a desserializa√ß√£o (quando o JSON √© convertido para um objeto Java), mas **n√£o ser√° inclu√≠da no JSON durante a serializa√ß√£o (quando o objeto Java √© convertido para JSON)**.

#### **Como funciona no contexto de cole√ß√µes mapeadas com `@OneToMany` e `@ManyToOne`:**

Quando voc√™ tem cole√ß√µes mapeadas com as anota√ß√µes **`@OneToMany`** ou **`@ManyToOne`**, o Hibernate ou JPA cuida do carregamento das associa√ß√µes entre as entidades, e voc√™ pode acabar com ciclos de refer√™ncia (ou seja, objetos que se referenciam uns aos outros). Isso pode causar problemas ao tentar serializar as entidades para JSON, pois o mecanismo de serializa√ß√£o pode entrar em um loop infinito se houver refer√™ncias circulares entre as entidades.

#### **Exemplo de problema:**
Considerando uma rela√ß√£o bidirecional entre duas entidades, como `Curso` e `Aluno`:

```java
@Entity
public class Curso {
    @OneToMany(mappedBy = "curso")
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private Set<Aluno> alunos;
}

@Entity
public class Aluno {
    @ManyToOne
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private Curso curso;
}
```

- No exemplo acima, a anota√ß√£o `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` √© aplicada nas propriedades que representam as cole√ß√µes de associa√ß√µes entre `Curso` e `Aluno`.
- Isso significa que, durante a **serializa√ß√£o** do objeto, as cole√ß√µes (ou associa√ß√µes) **n√£o ser√£o inclu√≠das no JSON**. Ou seja, quando voc√™ converter um `Curso` para JSON, a lista de `Alunos` associada ao curso **n√£o ser√° inclu√≠da no JSON**.
- Durante a **desserializa√ß√£o** (quando voc√™ est√° recebendo um JSON e transformando de volta em um objeto), as cole√ß√µes ser√£o **aceitas e populadas**, mas **n√£o aparecer√£o na resposta JSON**.

### **Cen√°rios de uso comuns:**
- **Evitar ciclos de refer√™ncia**: Quando voc√™ tem uma rela√ß√£o bidirecional entre as entidades, como no exemplo acima, o uso de `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` ajuda a evitar **loops infinitos** durante a serializa√ß√£o. Isso ocorre porque o Hibernate gerencia as associa√ß√µes de forma que, ao serializar o `Aluno`, ele n√£o tenta serializar novamente o `Curso` e vice-versa.
- **Filtragem de dados sens√≠veis**: Se voc√™ tiver dados que n√£o quer que sejam expostos via API (por exemplo, um conjunto de registros de transa√ß√µes, senhas ou outros dados sens√≠veis), a anota√ß√£o pode ser usada para ocult√°-los da serializa√ß√£o.

### **Exemplo de comportamento:**

Com a anota√ß√£o `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`, o comportamento seria o seguinte:

#### Serializa√ß√£o:
```json
{
  "id": 1,
  "nome": "Curso de Java"
}
```
Na serializa√ß√£o do `Curso`, a cole√ß√£o de `alunos` n√£o ser√° inclu√≠da no JSON.

#### Desserializa√ß√£o:
Suponha que voc√™ receba um JSON como este para criar um novo `Curso`:

```json
{
  "id": 1,
  "nome": "Curso de Java",
  "alunos": [
    { "id": 1, "nome": "Aluno 1" },
    { "id": 2, "nome": "Aluno 2" }
  ]
}
```

Aqui, os dados da cole√ß√£o de `alunos` seriam usados para **preencher o `Set<Aluno>`** na entidade `Curso`, mas **n√£o seriam retornados** na resposta de uma requisi√ß√£o.

### **Conclus√£o:**

A anota√ß√£o `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` √© uma maneira eficiente de controlar como as cole√ß√µes e associa√ß√µes s√£o tratadas ao converter objetos Java para JSON e vice-versa. Us√°-la acima de propriedades mapeadas com `@OneToMany` ou `@ManyToOne` ajuda a evitar problemas de **serializa√ß√£o circular** e pode ser √∫til para proteger ou omitir certos dados durante a **exposi√ß√£o de dados via API REST**.

No c√≥digo fornecido, voc√™ est√° usando v√°rias anota√ß√µes no campo `modules` de uma classe. Vamos analisar cada uma delas e explicar seu papel:

### 1. **`@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`**
   - **Objetivo**: Controla a serializa√ß√£o e desserializa√ß√£o de um campo durante a convers√£o entre objetos Java e JSON.
   - **`WRITE_ONLY`**: Significa que o campo ser√° **somente gravado** (aceito durante a desserializa√ß√£o do JSON para o objeto Java), mas **n√£o ser√° inclu√≠do no JSON** durante a serializa√ß√£o (quando o objeto Java √© convertido para JSON).
   - **Uso comum**: Quando voc√™ deseja permitir que um campo seja aceito como entrada (em uma requisi√ß√£o, por exemplo), mas n√£o deseja que ele seja exposto de volta na resposta. Isso pode ser √∫til, por exemplo, para evitar a exposi√ß√£o de dados sens√≠veis ou de cole√ß√µes em respostas da API.

### 2. **`@OneToMany(mappedBy = "course", fetch = FetchType.LAZY)`**
   - **Objetivo**: Define o relacionamento entre duas entidades no contexto do JPA (Java Persistence API). Neste caso, o relacionamento √© **"um para muitos"** entre a entidade que cont√©m o campo `modules` e a entidade `ModuleModel`.
   - **`mappedBy = "course"`**: Indica que o mapeamento do relacionamento √© feito pelo campo `course` na classe `ModuleModel`. Ou seja, a classe `ModuleModel` tem um atributo que aponta para a entidade que cont√©m o campo `modules`, e a responsabilidade do relacionamento est√° na outra ponta da associa√ß√£o.
   - **`fetch = FetchType.LAZY`**: Define o tipo de carregamento (fetching) da cole√ß√£o. **Lazy loading** significa que os `modules` n√£o ser√£o carregados automaticamente quando a entidade que os cont√©m for carregada. Em vez disso, eles ser√£o carregados sob demanda, ou seja, quando voc√™ acessar o campo `modules`. Isso pode melhorar a performance, especialmente quando voc√™ tem cole√ß√µes grandes, evitando o carregamento desnecess√°rio de dados.

### 3. **`@Fetch(FetchMode.SUBSELECT)`**
   - **Objetivo**: Esta anota√ß√£o √© espec√≠fica do Hibernate e √© usada para controlar o comportamento de **fetching** (carregamento de dados).
   - **`FetchMode.SUBSELECT`**: Quando essa estrat√©gia √© usada, o Hibernate carrega os dados associados de forma otimizada usando um subselect (subconsulta). Em vez de carregar os dados relacionados com uma consulta separada para cada entidade, o Hibernate utiliza uma subconsulta que retorna todos os dados em um √∫nico comando SQL. Isso pode melhorar a performance em casos onde h√° muitas entidades relacionadas, evitando o **N+1 Select Problem**.
   - **Uso comum**: Quando voc√™ deseja otimizar a recupera√ß√£o de dados em relacionamentos "um para muitos" ou "muitos para muitos", especialmente quando h√° muitas entidades associadas e voc√™ quer evitar m√∫ltiplas consultas SQL.

### 4. **`@OnDelete(action = OnDeleteAction.CASCADE)`**
   - **Objetivo**: Controla o comportamento de exclus√£o de registros no banco de dados. Especificamente, esta anota√ß√£o √© usada para definir o comportamento quando a entidade relacionada √© exclu√≠da.
   - **`OnDeleteAction.CASCADE`**: Quando uma entidade pai (neste caso, a entidade que cont√©m o campo `modules`) √© exclu√≠da, todas as entidades filhas (os `modules`) relacionadas ser√£o automaticamente exclu√≠das tamb√©m. Ou seja, se voc√™ excluir um `Course`, todos os `ModuleModel` relacionados ser√£o removidos do banco de dados. Isso ajuda a garantir a integridade referencial no banco de dados, removendo registros √≥rf√£os.
   - **Uso comum**: Usado em relacionamentos onde √© desejado que a exclus√£o de um registro pai resulte na exclus√£o autom√°tica dos registros filhos relacionados.

### 5. **`private Set<ModuleModel> modules;`**
   - **Objetivo**: Define o campo que armazenar√° a cole√ß√£o de entidades relacionadas. O tipo `Set<ModuleModel>` indica que voc√™ est√° usando uma cole√ß√£o do tipo `Set` para armazenar os m√≥dulos relacionados ao curso. `Set` √© uma cole√ß√£o que n√£o permite elementos duplicados, o que significa que cada m√≥dulo ser√° √∫nico para o curso.

### Resumo completo:

O campo `modules` da entidade √© uma cole√ß√£o **"um para muitos"** (`@OneToMany`) de `ModuleModel` que √© carregada **pregui√ßosamente (Lazy)**. Isso significa que, quando voc√™ carregar o `Course`, os `modules` n√£o ser√£o carregados imediatamente; eles ser√£o carregados quando voc√™ acess√°-los.

- A anota√ß√£o `@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)` garante que os m√≥dulos n√£o sejam retornados quando o `Course` for serializado para JSON (usado principalmente para evitar a exposi√ß√£o de dados sens√≠veis ou evitar ciclos de refer√™ncia).
- O `@Fetch(FetchMode.SUBSELECT)` faz com que o Hibernate use uma **subconsulta** para carregar os m√≥dulos, otimizando a recupera√ß√£o de dados em vez de fazer v√°rias consultas separadas.
- A anota√ß√£o `@OnDelete(action = OnDeleteAction.CASCADE)` garante que, quando um `Course` for exclu√≠do, todos os `ModuleModel` associados tamb√©m sejam exclu√≠dos automaticamente.

Essas anota√ß√µes ajudam a controlar o comportamento de carregamento de dados e a integridade do banco de dados em um relacionamento entre entidades, al√©m de melhorar a performance ao evitar consultas desnecess√°rias e garantir a consist√™ncia dos dados.

-- Filtros avan√ßados com Specification --

Esse c√≥digo define uma classe chamada `SpecificationTemplate`, que cont√©m especifica√ß√µes (`Specification<T>`) para consultas din√¢micas no Spring Data JPA, utilizando a biblioteca **Spring Data JPA Specifications** e o **Spec by Example (SPECS)** do pacote `net.kaczmarzyk.spring.data.jpa.domain`.  

O objetivo dessa abordagem √© permitir que consultas ao banco de dados sejam feitas de maneira flex√≠vel, aplicando filtros dinamicamente sem precisar escrever consultas SQL manualmente.

---

## üìå **Explica√ß√£o do C√≥digo**

### üîπ **Interfaces com `@Spec` e `@And`**
Essas interfaces servem para definir crit√©rios de busca que podem ser aplicados dinamicamente pelo Spring Data JPA.

```java
@And({
    @Spec(path = "courseLevel", spec = Equal.class),
    @Spec(path = "courseStatus", spec = Equal.class),
    @Spec(path = "name", spec = LikeIgnoreCase.class),
    @Spec(path = "userInstructor", spec = Equal.class)
})
public interface CourseSpec extends Specification<CourseModel> {}
```
- `@And({...})` ‚Üí Combina m√∫ltiplas especifica√ß√µes usando **AND** l√≥gico.
- `@Spec(...)` ‚Üí Define um crit√©rio de busca com base em um campo espec√≠fico.
- `Equal.class` ‚Üí Compara se o valor do campo √© **igual** ao par√¢metro da consulta.
- `LikeIgnoreCase.class` ‚Üí Aplica um filtro de **LIKE** ignorando diferen√ßas entre mai√∫sculas e min√∫sculas.

‚úÖ **Essa interface permite pesquisar cursos (`CourseModel`) filtrando por:**
  - `courseLevel` (**igualdade**)
  - `courseStatus` (**igualdade**)
  - `name` (**LIKE ignorando mai√∫sculas e min√∫sculas**)
  - `userInstructor` (**igualdade**)

---

```java
@Spec(path = "title", spec = LikeIgnoreCase.class)
public interface ModuleSpec extends Specification<ModuleModel> {}
```
- Especifica√ß√£o para **m√≥dulos (`ModuleModel`)** que permite buscas pelo t√≠tulo com **LIKE ignorando mai√∫sculas e min√∫sculas**.

```java
@Spec(path = "title", spec = LikeIgnoreCase.class)
public interface LessonSpec extends Specification<LessonModel> {}
```
- Especifica√ß√£o para **li√ß√µes (`LessonModel`)** com o mesmo comportamento.

---

## üîπ **M√©todo `moduleCourseId`**
```java
public static Specification<ModuleModel> moduleCourseId(final UUID courseId) {
    return (root, query, cb) -> {
        query.distinct(true);
        Root<ModuleModel> module = root;
        Root<CourseModel> course = query.from(CourseModel.class);
        Expression<Collection<ModuleModel>> courseModules = course.get("modules");
        return cb.and(cb.equal(course.get("courseId"), courseId), cb.isMember(module, courseModules));
    };
}
```
‚úÖ **Objetivo:** Criar uma especifica√ß√£o para buscar **m√≥dulos (`ModuleModel`)** que pertencem a um determinado **curso (`CourseModel`)**.

üîç **Explica√ß√£o:**
1. `query.distinct(true);` ‚Üí Garante que os resultados n√£o tenham duplicatas.
2. `Root<ModuleModel> module = root;` ‚Üí Define a raiz da consulta (`ModuleModel`).
3. `Root<CourseModel> course = query.from(CourseModel.class);` ‚Üí Adiciona `CourseModel` √† consulta.
4. `Expression<Collection<ModuleModel>> courseModules = course.get("modules");` ‚Üí Obt√©m a cole√ß√£o de m√≥dulos do curso.
5. `cb.and(cb.equal(course.get("courseId"), courseId), cb.isMember(module, courseModules));`
   - **Filtra os cursos cujo `courseId` √© igual ao passado na consulta.**
   - **Filtra os m√≥dulos que pertencem ao curso correspondente.**

---

## üîπ **M√©todo `lessonModuleId`**
```java
public static Specification<LessonModel> lessonModuleId(final UUID moduleId) {
    return (root, query, cb) -> {
        query.distinct(true);
        Root<LessonModel> lesson = root;
        Root<ModuleModel> module = query.from(ModuleModel.class);
        Expression<Collection<LessonModel>> moduleLessons = module.get("lessons");
        return cb.and(cb.equal(module.get("moduleId"), moduleId), cb.isMember(lesson, moduleLessons));
    };
}
```
‚úÖ **Objetivo:** Criar uma especifica√ß√£o para buscar **li√ß√µes (`LessonModel`)** que pertencem a um determinado **m√≥dulo (`ModuleModel`)**.

üîç **Explica√ß√£o:**
1. `query.distinct(true);` ‚Üí Garante que n√£o haja duplicatas.
2. `Root<LessonModel> lesson = root;` ‚Üí Define a raiz da consulta (`LessonModel`).
3. `Root<ModuleModel> module = query.from(ModuleModel.class);` ‚Üí Adiciona `ModuleModel` √† consulta.
4. `Expression<Collection<LessonModel>> moduleLessons = module.get("lessons");` ‚Üí Obt√©m a cole√ß√£o de li√ß√µes do m√≥dulo.
5. `cb.and(cb.equal(module.get("moduleId"), moduleId), cb.isMember(lesson, moduleLessons));`
   - **Filtra os m√≥dulos cujo `moduleId` √© igual ao passado na consulta.**
   - **Filtra as li√ß√µes que pertencem ao m√≥dulo correspondente.**

---

## üìå **Resumo**
- **Interfaces `CourseSpec`, `ModuleSpec` e `LessonSpec`**: Criam filtros din√¢micos baseados em campos espec√≠ficos das entidades.
- **M√©todo `moduleCourseId(UUID courseId)`**: Retorna os m√≥dulos pertencentes a um curso espec√≠fico.
- **M√©todo `lessonModuleId(UUID moduleId)`**: Retorna as li√ß√µes pertencentes a um m√≥dulo espec√≠fico.
- **Uso de `@Spec` e `@And`**: Permite que a API forne√ßa buscas din√¢micas sem a necessidade de criar queries manuais no reposit√≥rio.

Essa abordagem torna a aplica√ß√£o **mais flex√≠vel**, facilitando a cria√ß√£o de buscas avan√ßadas de maneira declarativa e reutiliz√°vel. üöÄ

-- Pagina√ß√£o global --

### üìå **Explica√ß√£o da Anota√ß√£o `@EnableSpringDataWebSupport(pageSerializationMode = VIA_DTO)`**  

A anota√ß√£o `@EnableSpringDataWebSupport` pertence ao **Spring Data** e serve para ativar suporte adicional para integra√ß√£o entre Spring MVC e Spring Data.  

üîç **No caso espec√≠fico:**  
```java
@EnableSpringDataWebSupport(pageSerializationMode = VIA_DTO)
public class ResolverConfig implements WebMvcConfigurer {
```
A op√ß√£o `pageSerializationMode = VIA_DTO` define que a serializa√ß√£o de **pagina√ß√£o (`Page<T>`)** ser√° feita atrav√©s de um **DTO (Data Transfer Object)** em vez do formato padr√£o.

---

## üîπ **O que `@EnableSpringDataWebSupport` faz?**
1. **Habilita suporte autom√°tico para pagina√ß√£o e ordena√ß√£o em requisi√ß√µes REST.**  
   - Permite que a API aceite par√¢metros `page`, `size`, `sort`, etc., automaticamente.  
   - Exemplo:  
     ```
     GET /courses?page=0&size=10&sort=name,asc
     ```
2. **Facilita a convers√£o de Strings para entidades em controladores.**  
   - Se um controlador recebe um ID e precisa convert√™-lo em uma entidade, o Spring faz isso automaticamente.  
3. **Melhora o suporte a `Page<T>` e `Slice<T>` no retorno de APIs REST.**  

---

## üîπ **O que significa `pageSerializationMode = VIA_DTO`?**
Por padr√£o, quando uma API retorna uma `Page<T>`, o Spring serializa toda a estrutura da `Page`, incluindo metadados como:
```json
{
  "content": [...], 
  "pageable": {...}, 
  "totalElements": 100, 
  "totalPages": 10, 
  "last": false
}
```
Isso pode expor **dados desnecess√°rios** para o cliente.

‚úÖ **Com `VIA_DTO`, o Spring permite personalizar essa sa√≠da!**  
Em vez de retornar toda a estrutura da `Page`, voc√™ pode definir um **DTO customizado** que ser√° usado para serializar os dados da resposta.

---

## üîπ **Exemplo de Uso**
Imagine que temos um **servi√ßo de cursos**, e queremos retornar apenas informa√ß√µes essenciais na resposta.

### **1Ô∏è‚É£ DTO Personalizado**
```java
public class CourseDTO {
    private UUID id;
    private String name;
    private String level;

    public CourseDTO(CourseModel course) {
        this.id = course.getId();
        this.name = course.getName();
        this.level = course.getCourseLevel();
    }

    // Getters e Setters
}
```

### **2Ô∏è‚É£ M√©todo no Controller**
```java
@GetMapping
public ResponseEntity<Page<CourseDTO>> getAllCourses(Pageable pageable) {
    Page<CourseModel> courses = courseService.findAll(pageable);
    
    // Converte para DTO antes de retornar
    Page<CourseDTO> dtoPage = courses.map(CourseDTO::new);
    
    return ResponseEntity.ok(dtoPage);
}
```
‚úÖ **Agora, a resposta conter√° apenas os campos que queremos no `CourseDTO`.**

---

## üîπ **Resumo**
- `@EnableSpringDataWebSupport` **ativa suporte avan√ßado do Spring Data para integra√ß√£o com Spring MVC.**
- **Habilita pagina√ß√£o e ordena√ß√£o autom√°tica** via par√¢metros de URL.
- `pageSerializationMode = VIA_DTO` **permite retornar uma vers√£o simplificada da `Page<T>` usando um DTO.**
- **Evita expor detalhes desnecess√°rios** na resposta da API REST.

üõ†Ô∏è **Melhora a flexibilidade e efici√™ncia da API, reduzindo o tamanho das respostas e aumentando o controle sobre os dados expostos.** üöÄ


-- WebMvcConfigurer -- 

### üìå **Prop√≥sito da Classe `ResolverConfig` implementando `WebMvcConfigurer`**  

A classe `ResolverConfig` que implementa `WebMvcConfigurer` √© usada para **configurar o Spring MVC** sem a necessidade de estender `WebMvcConfigurerAdapter` (que foi **descontinuado** no Spring 5).

---

## üîπ **O que `WebMvcConfigurer` faz?**  
A interface `WebMvcConfigurer` permite **personalizar o comportamento padr√£o do Spring MVC**, sem substituir a configura√ß√£o autom√°tica do Spring Boot.  

### **Principais usos**
- **Adicionar interceptadores** (`HandlerInterceptor`).
- **Configurar CORS** (Cross-Origin Resource Sharing).
- **Customizar a serializa√ß√£o e desserializa√ß√£o JSON**.
- **Definir conversores de formatos de dados** (como JSON ‚Üí Objeto).
- **Registrar resolvers de argumentos** (como inje√ß√£o de usu√°rio autenticado).
- **Personalizar a resolu√ß√£o de p√°ginas e templates** (como Thymeleaf ou JSP).

---

## üîπ **Exemplo da Classe `ResolverConfig`**
```java
@Configuration
@EnableSpringDataWebSupport(pageSerializationMode = VIA_DTO)
public class ResolverConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("https://meusite.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true);
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(new MappingJackson2HttpMessageConverter());
    }
}
```

---

## üîπ **Explica√ß√£o do Exemplo**
1. **`@Configuration`** ‚Üí Indica que esta classe √© uma classe de configura√ß√£o do Spring.  
2. **`@EnableSpringDataWebSupport(pageSerializationMode = VIA_DTO)`** ‚Üí Ativa suporte para pagina√ß√£o e ordena√ß√£o no Spring Data (como visto antes).  
3. **`addCorsMappings`** ‚Üí Configura **CORS**, permitindo requisi√ß√µes de origens espec√≠ficas.  
4. **`configureMessageConverters`** ‚Üí Define conversores para transformar objetos Java em JSON automaticamente.

---

## üîπ **Resumo**
A classe `ResolverConfig` implementa `WebMvcConfigurer` para **personalizar o comportamento do Spring MVC**, sem afetar a configura√ß√£o autom√°tica do Spring Boot.  

‚úÖ **Permite adicionar CORS, customizar JSON, configurar interceptadores e muito mais.**  
üöÄ **√ötil para ajustar a API conforme a necessidade sem sobrescrever as configura√ß√µes padr√£o.**
