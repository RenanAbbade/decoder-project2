Spring MVC pattern com Spring Web

password postgrees: 586910

- O framework Spring Web utiliza o padr√£o MVC
- No momento que a Request chega na API, o componente DispatcherServlet (Com o Spring Boot, as configura√ß√µes ficam encapsuladas), mas em resumo no momento em que a request chega, o DispatcherServlet recebe a solicita√ß√£o, e utilizar√° do HandlerMapping que ir√° fazer o mapeamento /roteamento encontrando qual controller ir√° responder a aquela request, que por sua vez ter√° acesso a camada de neg√≥cio e ir√° trabalhar com o modelo e l√≥gica de neg√≥cio.
- Em uma aplica√ß√£o que tamb√©m possui view, o DispatcherServlet utiliza o ViewResolver para reconhecer a view determinada da request.
- Tomcat: ServletContainer (Spring Web, encapsula o funcionamento).


Jakarta Bean Validation

√â uma especifica√ß√£o Java que possibilita trabalhar com valida√ß√µes e restri√ß√µes atrav√©s de anota√ß√µes.

Dependencia Spring Validation.

Annotations:

@NotBlank: Onde o atributo n√£o pode ser null e n√£o pode ser uma String vazia.

@Email: Verificar o padr√£o de email por meio de regex.

@NotNull: N√£o aceita valores nulos.

@Size: Define um tamanho limite de caracteres para a String.

@Min e @Max: Estabelece valores especificos no qual tipos Number s√£o delimitados.

@Past e @Future: Delimita campos do tipo Date e Calendar como passado e futuro respectivamente.

@AssertTrue @AssertFalse: Restringe que o atributo precisa ser booleano True ou False.

### Explica√ß√£o das Annotations `@Validated` e `@JsonView`

No seu c√≥digo, as annotations `@Validated` e `@JsonView` s√£o utilizadas para validar e controlar a serializa√ß√£o/desserializa√ß√£o dos dados, respectivamente.

---

### üìå **`@Validated`**
- Faz parte do **Spring** (`org.springframework.validation.annotation.Validated`).
- Permite validar objetos com **Bean Validation** (JSR-303/JSR-380), como `@NotBlank`, `@Size`, `@Email`, entre outras.
- Aceita **grupos de valida√ß√£o**, que permitem definir regras de valida√ß√£o diferentes para diferentes cen√°rios.

#### **No seu c√≥digo**
```java
@RequestBody @Validated(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Aqui, `@Validated(UserRecordDto.UserView.UserPut.class)` diz que apenas as valida√ß√µes associadas ao grupo `UserView.UserPut.class` devem ser aplicadas. Isso significa que, ao chamar esse endpoint, apenas os campos validados com esse grupo (por exemplo, `fullName` e `phoneNumber`) ser√£o checados.

---

### üìå **`@JsonView`**
- Faz parte do **Jackson** (`com.fasterxml.jackson.annotation.JsonView`).
- Controla **quais campos ser√£o serializados** (retornados na resposta) ou **desserializados** (recebidos no request).
- Funciona com **interfaces vazias** para definir diferentes "vis√µes" (`views`) de um mesmo DTO.

#### **No seu c√≥digo**
```java
@JsonView(UserView.RegistrationPost.class)
String username;
```
Isso significa que o campo `username` **s√≥ ser√° inclu√≠do na resposta se a view `UserView.RegistrationPost.class` estiver sendo usada**.

Da mesma forma, no m√©todo `updateUser`:
```java
@RequestBody @JsonView(UserRecordDto.UserView.UserPut.class)
UserRecordDto userRecordDto
```
Isso indica que **apenas os campos marcados com `UserPut` ser√£o desserializados do JSON enviado no request**.

---

### üöÄ **Resumindo**
1. **`@Validated`** ‚Üí Aplica **valida√ß√µes condicionais** dependendo do grupo especificado no request.
2. **`@JsonView`** ‚Üí Controla **quais campos aparecem na requisi√ß√£o e resposta**, dependendo da view definida.

Isso permite maior flexibilidade, garantindo que **diferentes endpoints apliquem regras e retornem apenas os dados necess√°rios**.
